```
_________     ______
__  ____/________  /_____ ______________ _
_  / __ _  __ \_  /_  __ `/_  __ \_  __ `/
/ /_/ / / /_/ /  / / /_/ /_  / / /  /_/ /
\____/  \____//_/  \__,_/ /_/ /_/_\__, /
                                 /____/
```
# Golang 中需要注意的地方

## map 注意点

<details> <summary> doc </summary>

map 在大多数语言中都是基于 hash table 来实现的。

hash 表通常会把键转换成 hash 值（一个 unsigned int 值），哈希表会持有一定数量的桶（bucket 哈希桶），会均匀的储存哈希表收纳的键 - 值对儿。hash table 会先用键的 hash 值的低几位去定位到一个 bucket，然后去这个 bucket 中查找这个键。然后在用这个键去找到对应的值。

### map 的 key 不能为哪些类型？函数、字典和切片
在 go 中字典的键类型不能是那些类型：** 函数、字典类型和切片类型 **。这是因为键的类型必须可以是可以施加 `=` 或 `!=` 符号类型的。上面三种类型不支持判等操作。

另外如过键的类型是接口类型的，那么键值的类型实际类型也不能是上面 3 中类型，** 否则会在程序运行时候引发 panic** `panic: runtime error: hash of unhashable type []int`
```go
func Test_InterfaceKey(t *testing.T) {
	var mapT = map[interface{}]int{
		[]int{4}: 4,   // panic: runtime error: hash of unhashable type []int
		3:        3,
	}
}
```
另外，如果键的类型为：** 数组类型 **，那么应该确定该类型的元素类型不是 ** 函数类型、字典或切片类型 **。
### 为什么键必须支持判等操作呢？
每个 bucket 会把自己包含的所有键的 hash 值存起来，在 bucket 中定位的时候，会使用被查找的 hash 值和和 bucket 中 hash 值逐个进行比较。只有键的哈希值和键值都相等，才能说明查找 到了匹配的键 - 元素对。

### 优先选用哪些类型作为字典的键类型 ？
求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。

对于基本类型来说：
- 所有的基本类型，指针类型，以及数组类型、结构体类型和接口类型，go 中都有一套 hash 算法来算对应的 hash 值，、
- 宽度越小的类型速度越快，`bool`、`int`、`float`、`complex` 和 `pointer` 类型。对于字符串来说，需要看他的具体长度，长度越短求 hash 越快。
- 类型的宽度是指它的单个值需要占用的字节数。比如，bool、int8 和 uint8 类型的一个值 需要占用的字节数都是 1，因此这些类型的宽度就都是 1。

对于高级类型来说：
- 对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以 关键在于它的各个字段的类型以及字段的数量。
- 对于接口类型，具体的哈希算法，则由值的实际类型决定。
- 把接口类型作为字典的键类型最危险。

** 优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。**

### 在值为 `nil` 的字典上执行读和写操作会成功吗？
除了 ** 添加 ** 键 - 元素对，我们在一个值为 nil 的 map 上做任何操作都不会引 起错误。当我们试图在一个值为 nil 的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。

```go
func Test_Map(t *testing.T) {
	var m map[string]int
	key := "second"
	// get from a nil map. OK
	elem, ok := m["second"]
	// del from a nil map. OK
	delete(m, key)

	elem = 2
	// set in a nil map. NOT OK: panic: assignment to entry in nil map [recovered]
	m["second"] = elem
}
```

</details>


## channel
> Rob Pike: Don't communicate by sharing memory,share memory by communicating.
<details><summary>doc</summary>

通道类型本身的值就是并发安全的，是 Go 语言**自带的唯一一个可以满足并发安全性** 的类型。

在声明chan的时候，当容量为0时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。而当容量大于0 时，我们可以称为缓冲通道，也就是带有缓冲的通道。

**一个通道相当于一个先进先出(FIFO)的队列。**

### 对通道的发送和接收操作的基本特性?
1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
2. 发送操作和接收操作中对元素值的处理都是不可分割的。
3. 发送操作在完全完成之前会被阻塞。接收操作也是如此。

要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并 不是在接收操作符右边的那个元素值，而是它的副本。

### 发送操作和接收操作在什么时候可能被长时间的阻塞?
- 缓冲通道: 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道 中有元素值被接收走。
- 非缓冲通道: 无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。(同步传递消息)

### 发送操作和接收操作在什么时候会引发 panic?
- 通道一旦关闭的情况下,在对其进行操作会发生 panic。
- 如果我们试图关闭一个已经关闭了的通道，也会引发 panic。

### 通道底层存储数据的是链表还是数组? 环形链表

### 单项通道
- `chan<-` send
- `<-chan` revc

> 感觉chanel有点像socket的同步阻塞模式，只不过channel的发送端和接收端共享一个缓 冲，套接字则是发送这边有发送缓冲，接收这边有接收缓冲，而且socket接收端如果先 close的话，发送端再发送数据的也会引发panic(linux上会触发SIG_PIPE信号，不处理程序就崩溃了)。
> Go语言里没有深层复制。数组是值类型，所以会被完全复制
> 通道必须要手动关闭吗?go会自动清理吗?   需要手动关闭，这是个很好的习惯，而且也可以利用关的动作来给接收方传递一个信号。Go的GC只会清理被分配到堆上的、不再有任何引用的对象。
> 不要从接受端关闭channel算是基本原则了，另外如果有多个并发发送者，1个或多个接收 者，有什么普适选择可以分享吗? 可以用另外的标志位做，比如context。
> 浅拷贝只是拷贝值以及值中直接包含的东西，深拷贝就是把所有深层次的结构一并拷贝.
</details>







## func
在 Go 语言中，函数可是一等的(first-class)公民，函数类型也是一等的数据类型。

简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通 的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样。

而更深层次的含义就是:函数值可以由此成为能够被随意传播的独立逻辑组件(或者说功能 模块)。
<details><summary>doc</summary>

对于函数类型来说，它是一种对一组输入、输出进行模板化的重要工具，它比接口类型更加 轻巧、灵活，它的值也借此变成了可被热替换的逻辑组件。

```go
import "fmt"

type Printer func(content string) (n int, err error)

func printToStd(s string) (n int, err error) {
	return fmt.Println(s)
}

func main() {
	var p Printer
	p = printToStd
	p("hello")
}

```
### 高阶函数
什么是高阶函数:
1. 接受其他的函数作为参数传入;
2. 把其他的函数作为结果返回。

```go
type operate func(x, y int) int

func calc(x, y int, op operate) (int, error) {
	if op == nil {
		return 0, errors.New("invalid operation")
	}
	return op(x, y), nil
}

func main() {
	x, y := 12, 23
	op := func(x, y int) int {
		return x * y
	}
	result, err := calc(x, y, op)
	fmt.Printf("The result: %d (error: %v)\n", result, err)
}

```

### 闭包 TODO TODO

</details>

## struct

<details><summary>doc</summary>

>函数是独立的程序实体。我们可以声明有名字的函数，也可以声明没名字的函数，还可以把 它们当做普通的值传来传去。我们能把具有相同签名的函数抽象成独立的函数类型，以作为 一组输入、输出(或者说一类逻辑组件)的代表。

> 方法却不同，它需要有名字，不能被当作值来看待，最重要的是，它必须隶属于某一个类 型。方法所属的类型会通过其声明中的接收者(receiver)声明体现出来。

> 接收者声明就是在关键字func和方法名称之间的圆括号包裹起来的内容，其中必须包含确 切的名称和类型字面量。

> 接收者的类型其实就是当前方法所属的类型，而接收者的名称，则用于在当前方法中引用它 所属的类型的当前值。

更宽泛地讲，如果结构体类型的某个字段声明中只有一个类型名，那么该字段代表了什么?

Go 语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么
它就是一个嵌入字段，也可以被称为匿名字段。我们可以通过此类型变量的名称后 跟“`.`”，再后跟嵌入字段类型的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。

问题 1: Go 语言是用嵌入字段实现了继承吗?

> 这里强调一下，Go 语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类 型之间的组合。这样做的具体原因和理念请见 Go 语言官网的 FAQ 中的Why is there no type inheritance?。

问题 2:值方法和指针方法都是什么意思，有什么区别?

值方法:
```go
func (cat Cat) String() string {
	return fmt.Sprintf("%s (category: %s, name: %q)",
	cat.scientificName, cat.Animal.AnimalCategory, cat.name)
}
```
指针方法:
```go
func (cat *Cat) SetName(name string) {
	cat.name = name
}
```


> 1. 值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修 改一般都不会体现在原值上，除非这个类型本身是某个引用类型(比如切片或字典)的 别名类型。而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。

*一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。*

> 2. **一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。** 严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go 语言会适时 地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法。比如，在Cat类型的变量cat之上，之所以我们可以通过`cat.SetName("monster")`修改猫的名字，是因为 Go 语言把它自动转译为了(&cat).SetName("monster")， 即:先取cat的指针值，然后在该指针值上调用SetName方法。
> 3. 在后边你会了解到，一个类型的方法集合中有哪些方法与它能实现哪些接口类型是息息 相关的。如果一个基本类型和它的指针类型的方法集合是不同的，那么它们具体实现的 接口类型的数量就也会有差异，除非这两个数量都是零。比如，一个指针类型实现了某某接口类型，但它的基本类型却不一定能够作为该接口的 实现类型。能够体现值方法和指针方法之间差异的小例子我放在 demo30.go 文件里了，你可以参照 一下。


**最后，再次强调，嵌入字段是实现类型间组合的一种方式，这与继承没有半点儿关系。Go 语言虽然支持面向对象编程，但是根本就没有“继承”这个概念。**

</details>

## interface
<details><summary>doc</summary>

在 Go 语言的语境中，当我们在谈论“接口”的时候，一定指的是接口类型。因为接口类型与其他数据类型不同，它是没法被实例化的。

更具体地说，我们既不能通过调用new函数或make函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值。

接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。

e.g. 声明的类型Dog附带了 3 个方法。其中有 2 个值方法，分别是Name和Category，另外 还有一个指针方法SetName。

接口:
```go
type Pet interface {
	SetName(name string)
	Name() string
	Category() string
}
```

类型:
```go
type Dog struct {
	name string // 名字。
}
func (dog *Dog) SetName(name string) {
	dog.name = name
}
func (dog Dog) Name() string {
	return dog.name
}
func (dog Dog) Category() string {
	return "dog"
}
```
这就意味着，Dog类型本身的方法集合中只包含了 2 个方法，也就是所有的值方法。而它的 指针类型`*Dog`方法集合却包含了 3 个方法，

也就是说，它拥有Dog类型附带的所有值方法和指针方法。又由于这 3 个方法恰恰分别是 Pet接口中某个方法的实现，所以`*Dog`类型就成为了Pet接口的实现类型。

正因为如此，我可以声明并初始化一个Dog类型的变量dog，然后把它的指针值赋给类型为 Pet的变量pet。

```go
dog := Dog{"little pig"}
var pet Pet = &dog
```
这里有几个名词需要你先记住。对于一个接口类型的变量来说，例如上面的变量 pet，我们赋给它的值可以被叫做它的**实际值(也称动态值)**，而该值的类型可以被叫做这个变量的**实际类型(也称动态类型)**。

比如，我们把取址表达式`&dog`的结果值赋给了变量`pet`，这时这个结果值就是变量`pet`的 动态值，而此结果值的类型`*Dog`就是该变量的动态类型。

动态类型这个叫法是相对于静态类型而言的。对于变量pet来讲，**它的静态类型就是Pet， 并且永远是Pet，但是它的动态类型却会随着我们赋给它的动态值而变化。**

接口 类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是nil，这也是它的 零值。

反过来讲，一旦它被赋予了某个实现类型的值，它的值就不再是nil了。不过要注意，即使我们像前面那样把dog的值赋给了pet，pet的值与dog的值也是不同的。这不仅仅是副本与原值的那种不同。

> 当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专 用的数据结构中。

> 严格来讲，这样一个变量的值其实是这个专用数据结构的一个实例，而不是我们赋给该变量 的那个实际的值。所以我才说，pet的值与dog的值肯定是不同的，无论是从它们存储的内 容，还是存储的结构上来看都是如此。不过，我们可以认为，这时pet的值中包含了dog值 的副本。

>我们就把这个专用的数据结构叫做 `iface`吧，在 Go 语言的runtime包中它其实就叫这个 名字。

> `iface` 的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。 这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使 它实现了接口的方法和调用它们的途径，等等。

只要我们把一个有类型的nil赋给接口变量，那么这个变量的值就一定不会是那个真正的 nil。因此，当我们使用判等符号==判断pet是否与字面量nil相等的时候，答案一定会是 false。

那么，怎样才能让一个接口变量的值真正为nil呢?要么只声明它但不做初始化，要么直接 把字面量nil赋给它。

### 接口组合和 struct 组合类似
接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间 有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如 此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。

Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程 序、增加程序的灵活性。

</details>

## pointer
<details><summary>doc</summary>
再来看 Go 语言标准库中的unsafe包。unsafe包中有一个类型叫做Pointer，也代表 了“指针”。

unsafe.Pointer可以表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和 uintptr 值之间的桥梁。也就是说，通过它，我们可以在这两种值之上进行双向的转换。 这里有一个很关键的词——可寻址的(addressable)。在我们继续说unsafe.Pointer 之前，需要先要搞清楚这个词的确切含义。

### 你能列举出 Go 语言中的哪些值是不可寻址的吗?
1. 第一个关键词:不可变的。由于 Go 语言中的字符串值也是不可变的，所以对于一个字符串 类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的，因为即使拿到了这种值 的内存地址也改变不了什么。
2. 算术操作的结果值属于一种临时结果。在我们把这种结果值赋给任何变量或常量之前，即使 能拿到它的内存地址也是没有任何意义的。第二个关键词:临时结果。这个关键词能被用来解释很多现象。我们可以把各种对值字面量 施加的表达式的求值结果都看做是临时结果。
3. 第三个关键词:不安全的。“不安全的”操作很可能会破坏程序的一致性，引发不可预知的 错误，从而严重影响程序的功能和稳定性。
### 怎样通过unsafe.Pointer操纵可寻址的值?

```go

dog := Dog{"little pig"}
dogP := &dog
dogPtr := uintptr(unsafe.Pointer(dogP))
namePtr := dogPtr + unsafe.Offsetof(dogP.name)
nameP := (*string)(unsafe.Pointer(namePtr))

```
这里需要与unsafe.Offsetof函数搭配使用才能看出端倪。unsafe.Offsetof函数用 于获取两个值在内存中的起始存储地址之间的偏移量，以字节为单位。

这两个值一个是某个字段的值，另一个是该字段值所属的那个结构体值。我们在调用这个函 数的时候，需要把针对字段的选择表达式传给它，比如dogP.name。
</details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
<details><summary>doc</summary></details>
